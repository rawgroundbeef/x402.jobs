---
phase: 02-creator-template-ui
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/components/modals/CreateResourceModal.tsx
  - src/types/prompt-template.ts
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Creator can click Edit on a published template and see pre-filled form"
    - "Creator can modify template fields and save changes"
    - "Edited template updates in place (same URL, same ID)"
  artifacts:
    - path: "src/components/modals/CreateResourceModal.tsx"
      provides: "Edit mode for prompt templates"
      contains: "isEditMode.*prompt_template"
  key_links:
    - from: "CreateResourceModal.tsx"
      to: "/resources/{id}"
      via: "authenticatedFetch PATCH"
      pattern: "PATCH.*resources"
---

<objective>
Add edit mode support for prompt templates so creators can modify published templates.

Purpose: CRTR-09 (edit published template) completes the creator workflow. Creators need to iterate on their prompts after publishing based on user feedback or to fix issues.

Output: Creator can edit any field of a published prompt template. Changes persist via PATCH API and template URL remains unchanged.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-creator-template-ui/02-CONTEXT.md
@.planning/phases/02-creator-template-ui/02-02-SUMMARY.md (after Plan 02 completes)
@src/components/modals/CreateResourceModal.tsx
@src/types/prompt-template.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend EditResourceData and detect prompt_template edit mode</name>
  <files>src/components/modals/CreateResourceModal.tsx, src/types/prompt-template.ts</files>
  <action>
1. Update the EditResourceData interface to include prompt template fields:
   ```typescript
   interface EditResourceData {
     id: string;
     name: string;
     description?: string | null;
     network: string;
     price_usdc: string;
     resource_type: "external" | "proxy" | "prompt_template";
     resource_url?: string;
     avatar_url?: string | null;
     category?: string;
     slug?: string;
     // Prompt template specific fields (optional, only for prompt_template type)
     pt_system_prompt?: string;
     pt_parameters?: Array<{
       name: string;
       description: string;
       required: boolean;
       default?: string;
     }>;
     pt_model?: string;
     pt_max_tokens?: number;
     pt_allows_user_message?: boolean;
   }
   ```

2. Update the useEffect that initializes forms for edit mode to handle prompt_template:

   ```typescript
   useEffect(() => {
     if (editResource && isOpen) {
       setStep("form");
       setResourceType(editResource.resource_type);

       if (editResource.resource_type === "prompt_template") {
         // Populate prompt template form
         promptTemplateForm.reset({
           name: editResource.name || "",
           slug: editResource.slug || "",
           description: editResource.description || "",
           category: editResource.category || "",
           avatar_url: editResource.avatar_url || "",
           price_usdc: editResource.price_usdc || "0.01",
           network: (editResource.network as "base" | "solana") || "base",
           system_prompt: editResource.pt_system_prompt || "",
           parameters: editResource.pt_parameters || [],
           max_tokens: editResource.pt_max_tokens || 4096,
           allows_user_message: editResource.pt_allows_user_message || false,
         });
       } else {
         // Existing edit form logic for external/proxy
         editForm.reset({
           name: editResource.name || "",
           description: editResource.description || "",
           category: editResource.category || "data",
           avatarUrl: editResource.avatar_url || "",
         });
       }
     }
   }, [editResource, isOpen, editForm, promptTemplateForm]);
   ```

3. Update dialog title handling to show "Edit Prompt Template" when editing:
   - In the title section where isEditMode is handled, add:
   ```tsx
   {
     isEditMode && resourceType === "prompt_template" && (
       <span className="text-xs px-2 py-0.5 rounded bg-purple-500/10 text-purple-500">
         Prompt Template
       </span>
     );
   }
   ```
   </action>
   <verify>

- Pass an editResource with resource_type: "prompt_template" to the modal
- Verify form opens directly in edit mode (skips type selection)
- Verify all fields are pre-populated with existing values
- Verify title shows "Edit Resource" with "Prompt Template" badge
  </verify>
  <done>Edit mode correctly detects and initializes prompt template form</done>
  </task>

<task type="auto">
  <name>Task 2: Update form UI for edit mode (read-only fields, edit-specific labels)</name>
  <files>src/components/modals/CreateResourceModal.tsx</files>
  <action>
1. In the prompt template form section, handle edit mode differences:
   - Network: Show as read-only in edit mode (same as proxy edit mode)
   - Slug: Hide in edit mode (cannot change URL)
   - Other fields: Editable

2. Update the form rendering to check isEditMode:

   ```tsx
   {/* Network - read-only in edit mode */}
   <div>
     <Label>
       Network{" "}
       {isEditMode && (
         <span className="text-xs text-muted-foreground">
           (cannot be changed)
         </span>
       )}
     </Label>
     <div className="flex items-center gap-2 mt-1.5">
       {(["base", "solana"] as const).map((net) => (
         <button
           key={net}
           type="button"
           onClick={() => {
             if (!isEditMode) {
               promptTemplateForm.setValue("network", net);
               const currentSlug = promptTemplateForm.getValues("slug");
               if (currentSlug) {
                 debouncedSlugCheck(currentSlug, net);
               }
             }
           }}
           disabled={isEditMode}
           className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-all ${
             promptTemplateForm.watch("network") === net
               ? "border-primary bg-primary/5 text-foreground"
               : "border-border bg-background text-muted-foreground hover:bg-accent"
           } ${isEditMode ? "opacity-60 cursor-not-allowed" : ""}`}
         >
           <ChainIcon network={net} className="w-4 h-4" />
           <span className="text-sm font-medium capitalize">{net}</span>
         </button>
       ))}
     </div>
   </div>

   {/* Slug - only shown in create mode */}
   {!isEditMode && (
     // ... existing slug section ...
   )}

   {/* Resource URL - show in edit mode */}
   {isEditMode && editResource?.resource_url && (
     <div>
       <Label>Resource URL</Label>
       <div className="mt-1.5 px-3 py-2 bg-muted/50 rounded-md border border-border">
         <code className="text-sm text-muted-foreground break-all">
           {editResource.resource_url}
         </code>
       </div>
       <p className="text-xs text-muted-foreground mt-1">
         URL cannot be changed after creation
       </p>
     </div>
   )}
   ```

3. Price field handling in edit mode:
   - Show current price as read-only or allow editing depending on business rules
   - For v1, make price editable (creator can update their markup)
     </action>
     <verify>

- In edit mode, network selection is disabled
- In edit mode, slug input is hidden
- In edit mode, resource URL is shown as read-only
- All other fields (name, description, system_prompt, parameters, settings) remain editable
  </verify>
  <done>Edit mode UI shows correct read-only vs editable fields</done>
  </task>

<task type="auto">
  <name>Task 3: Implement PATCH submission for prompt template updates</name>
  <files>src/components/modals/CreateResourceModal.tsx</files>
  <action>
1. Create handleUpdatePromptTemplate function:
   ```typescript
   const handleUpdatePromptTemplate = async (data: CreatePromptTemplateInput) => {
     if (!editResource) return;

     setError("");
     setIsSubmitting(true);

     try {
       const body = {
         name: data.name.trim(),
         description: data.description?.trim() || null,
         category: data.category?.trim() || null,
         avatarUrl: data.avatar_url?.trim() || null,
         priceUsdc: parseFloat(data.price_usdc),
         // Prompt template specific fields
         systemPrompt: data.system_prompt,
         parameters: data.parameters,
         maxTokens: data.max_tokens,
         allowsUserMessage: data.allows_user_message,
       };

       const res = await authenticatedFetch(`/resources/${editResource.id}`, {
         method: "PATCH",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify(body),
       });

       if (!res.ok) {
         const responseData = await res.json();
         throw new Error(responseData.error || "Failed to update prompt template");
       }

       onSuccess?.();
       handleClose();
     } catch (err) {
       setError(
         err instanceof Error ? err.message : "Failed to update prompt template"
       );
     } finally {
       setIsSubmitting(false);
     }

};

````

2. Update the DialogFooter to handle edit mode for prompt_template:
```tsx
{step === "form" && resourceType === "prompt_template" && (
  <>
    <Button
      variant="ghost"
      onClick={handleClose}
      disabled={isSubmitting}
    >
      Cancel
    </Button>
    <Button
      onClick={
        isEditMode
          ? promptTemplateForm.handleSubmit(handleUpdatePromptTemplate)
          : promptTemplateForm.handleSubmit(handleCreatePromptTemplate)
      }
      disabled={
        isSubmitting ||
        (!isEditMode && (isCheckingSlug || (slugStatus !== null && !slugStatus.available)))
      }
      variant="primary"
    >
      {isSubmitting ? (
        <>
          <Loader2 className="w-4 h-4 animate-spin mr-2" />
          {isEditMode ? "Saving..." : "Creating..."}
        </>
      ) : isEditMode ? (
        "Save Changes"
      ) : (
        "Create Template"
      )}
    </Button>
  </>
)}
````

3. Ensure handleClose resets promptTemplateForm as well (should already be done from Plan 01):
   ```typescript
   promptTemplateForm.reset();
   ```
   </action>
   <verify>

- Edit an existing prompt template
- Modify name, description, system_prompt, add/remove parameters
- Click "Save Changes"
- Verify PATCH request sent to /resources/{id}
- Verify request body contains updated fields
- Verify modal closes on success
- Verify error displays on failure
  </verify>
  <done>PATCH submission updates prompt templates in place</done>
  </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete prompt template creation and editing flow</what-built>
  <how-to-verify>
1. Open the app at http://localhost:3000 (or current dev URL)
2. Navigate to Dashboard -> Resources
3. Click "Create Resource" button
4. Verify three options appear: Register Existing, Create New, Prompt Template
5. Select "Prompt Template"
6. Fill in:
   - Name: "Test Template"
   - Let slug auto-generate
   - Description: "A test template"
   - Category: Select any
   - Price: 0.05
   - System prompt: "You are an expert in {topic}{/topic}. Explain {concept}{/concept} clearly."
   - Add parameter "topic" (required, no default)
   - Add parameter "concept" (not required, default "the basics")
   - Set max_tokens to 2048
   - Enable allows_user_message
7. Click "Create Template"
8. Check Network tab for the POST request payload
9. If creation succeeded, find the template in the resources list
10. Click Edit on the template
11. Verify form pre-populates with all values
12. Modify the description and add a new parameter
13. Click "Save Changes"
14. Check Network tab for PATCH request
15. Verify changes persisted

Note: API endpoints may not be implemented yet. If you get 404 or "not implemented" errors, that's expected - verify the request payloads are correctly structured.
</how-to-verify>
<resume-signal>Type "approved" if the flow works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Type checking: `npm run typecheck` passes
2. Build: `npm run build` succeeds
3. Manual test:
   - Create a new prompt template with all fields populated
   - Edit the created template
   - Modify fields and save
   - Verify changes persisted (if backend supports it)
4. Request payloads:
   - POST /resources/instant contains all prompt template fields
   - PATCH /resources/{id} contains updated fields only
</verification>

<success_criteria>

- [ ] EditResourceData interface includes prompt template fields
- [ ] Edit mode initializes form with existing template data
- [ ] Network/slug read-only in edit mode, other fields editable
- [ ] Resource URL shown as read-only in edit mode
- [ ] PATCH request sends correct payload to /resources/{id}
- [ ] Modal closes and calls onSuccess after successful update
- [ ] Error handling displays API errors
- [ ] TypeScript compiles without errors
- [ ] Human verification confirms end-to-end flow works
      </success_criteria>

<output>
After completion, create `.planning/phases/02-creator-template-ui/02-03-SUMMARY.md`
</output>
