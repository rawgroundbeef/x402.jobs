---
phase: 03-server-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - x402-jobs-api/src/routes/integrations.ts
  - migrations/002_add_claude_integration.sql
  - migrations/README.md
autonomous: true
user_setup:
  - service: supabase
    why: "Apply database migration for Claude integration table"
    dashboard_config:
      - task: "Run SQL migration 002_add_claude_integration.sql"
        location: "Supabase Dashboard > SQL Editor"

must_haves:
  truths:
    - "Frontend can fetch Claude integration status from /integrations/claude/config"
    - "Frontend can save Claude API key to /integrations/claude/config"
    - "API key is encrypted before storage"
    - "API key can be decrypted for execution"
  artifacts:
    - path: "x402-jobs-api/src/routes/integrations.ts"
      provides: "Claude integration GET/PUT endpoints"
      contains: "claude/config"
    - path: "migrations/002_add_claude_integration.sql"
      provides: "Database table for Claude configs"
      contains: "x402_user_claude_configs"
  key_links:
    - from: "ClaudeCard.tsx (frontend)"
      to: "/integrations/claude/config"
      via: "SWR fetch"
      pattern: "integrations/claude/config"
    - from: "integrations.ts"
      to: "encrypt.ts"
      via: "encryptSecret/decryptSecret"
      pattern: "encryptSecret|decryptSecret"
---

<objective>
Create the Claude integration backend infrastructure that the ClaudeCard frontend component already expects.

Purpose: Phase 2 created the ClaudeCard UI that fetches from `/integrations/claude/config`. This plan creates the actual backend endpoints and database table to support it.

Output: Working Claude integration endpoints (GET/PUT) with encrypted API key storage in x402_user_claude_configs table.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-server-execution/03-RESEARCH.md

# Prior phase artifacts

@.planning/phases/02-creator-template-ui/02-04-SUMMARY.md (ClaudeCard expects these endpoints)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for Claude integration table</name>
  <files>migrations/002_add_claude_integration.sql, migrations/README.md</files>
  <action>
Create SQL migration file `migrations/002_add_claude_integration.sql` with:

```sql
-- Migration: Add Claude integration table for user API keys
-- Following pattern from x402_user_telegram_configs

CREATE TABLE IF NOT EXISTS x402_user_claude_configs (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  api_key_encrypted TEXT NOT NULL,
  is_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE x402_user_claude_configs ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only read/write their own config
CREATE POLICY "Users can manage their own Claude config"
  ON x402_user_claude_configs
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Service role can access all for backend execution
CREATE POLICY "Service role full access"
  ON x402_user_claude_configs
  FOR ALL
  TO service_role
  USING (true);

-- Index for quick lookups during execution
CREATE INDEX idx_claude_configs_user_enabled
  ON x402_user_claude_configs(user_id, is_enabled);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_claude_config_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER claude_config_updated_at
  BEFORE UPDATE ON x402_user_claude_configs
  FOR EACH ROW
  EXECUTE FUNCTION update_claude_config_updated_at();
```

Update `migrations/README.md` to add:

- Entry for 002_add_claude_integration.sql
- Instructions to run via Supabase SQL Editor
- Note about service role access for backend execution
  </action>
  <verify>
- File exists at migrations/002_add_claude_integration.sql
- SQL is syntactically valid (no obvious errors)
- README.md updated with migration entry
  </verify>
  <done>
  Migration file ready for user to apply in Supabase Dashboard.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add Claude integration endpoints to integrations.ts</name>
  <files>x402-jobs-api/src/routes/integrations.ts</files>
  <action>
Add Claude integration endpoints to the existing integrations router following the TelegramCard pattern from RESEARCH.md.

**IMPORTANT:** This is in the x402-jobs-api repo, not the x402-jobs (frontend) repo. The path is:
`/Users/rawgroundbeef/Projects/memeputer/apps/x402-jobs-api/src/routes/integrations.ts`

Read the existing file first to understand the patterns, then add:

**GET /integrations/claude/config** - Fetch current status

```typescript
// Returns { hasApiKey: boolean, isEnabled: boolean }
// Never returns the actual API key
integrationsRouter.get(
  "/claude/config",
  authMiddleware,
  async (req: Request, res: Response) => {
    const userId = req.user!.id;
    const { data, error } = await getSupabase()
      .from("x402_user_claude_configs")
      .select("is_enabled")
      .eq("user_id", userId)
      .single();

    if (error && error.code !== "PGRST116") {
      return res.status(500).json({ error: "Failed to load Claude settings" });
    }

    res.json({
      hasApiKey: Boolean(data),
      isEnabled: data?.is_enabled ?? false,
    });
  },
);
```

**PUT /integrations/claude/config** - Save API key

```typescript
// Accepts { apiKey?: string, isEnabled?: boolean }
// Encrypts API key before storage
integrationsRouter.put(
  "/claude/config",
  authMiddleware,
  async (req: Request, res: Response) => {
    const userId = req.user!.id;
    const { apiKey, isEnabled } = req.body || {};

    // Build upsert payload
    const payload: Record<string, unknown> = { user_id: userId };

    if (apiKey !== undefined) {
      // Encrypt API key before storage
      payload.api_key_encrypted = encryptSecret(apiKey);
    }

    if (isEnabled !== undefined) {
      payload.is_enabled = isEnabled;
    }

    const { error } = await getSupabase()
      .from("x402_user_claude_configs")
      .upsert(payload, { onConflict: "user_id" });

    if (error) {
      return res.status(500).json({ error: "Failed to save Claude settings" });
    }

    res.json({
      success: true,
      hasApiKey: apiKey !== undefined ? true : undefined,
      isEnabled: isEnabled ?? true,
    });
  },
);
```

Make sure to import `encryptSecret` from the encrypt utility (should already be imported for Telegram).
</action>
<verify>

- GET /integrations/claude/config endpoint exists
- PUT /integrations/claude/config endpoint exists
- Both use authMiddleware for authentication
- API key is encrypted via encryptSecret before storage
- Response never includes actual API key, only hasApiKey boolean
  </verify>
  <done>
  Claude integration endpoints ready. ClaudeCard frontend can now:

1. Check if user has Claude API key configured
2. Save/update their Claude API key (encrypted storage)
   </done>
   </task>

<task type="auto">
  <name>Task 3: Add helper function to retrieve decrypted API key</name>
  <files>x402-jobs-api/src/routes/integrations.ts</files>
  <action>
Add an exported helper function that can be used by the execution engine (Plan 03-02) to retrieve and decrypt a user's Claude API key.

```typescript
/**
 * Get a user's decrypted Claude API key for execution.
 * Used by prompt_template executor in instant.ts.
 *
 * @param userId - The user ID (resource owner)
 * @returns Decrypted API key or null if not configured/disabled
 */
export async function getCreatorClaudeApiKey(
  userId: string,
): Promise<string | null> {
  const { data, error } = await getSupabase()
    .from("x402_user_claude_configs")
    .select("api_key_encrypted, is_enabled")
    .eq("user_id", userId)
    .single();

  if (error || !data?.api_key_encrypted || !data.is_enabled) {
    return null;
  }

  return decryptSecret(data.api_key_encrypted);
}
```

Make sure `decryptSecret` is imported from the encrypt utility.
</action>
<verify>

- Function `getCreatorClaudeApiKey` is exported
- Function uses decryptSecret to decrypt the stored key
- Returns null if not found, disabled, or error
  </verify>
  <done>
  Execution engine can now call `getCreatorClaudeApiKey(userId)` to get the decrypted API key for Claude calls.
  </done>
  </task>

</tasks>

<verification>
1. Migration file exists and has valid SQL structure
2. GET /integrations/claude/config returns { hasApiKey: boolean, isEnabled: boolean }
3. PUT /integrations/claude/config accepts { apiKey: string, isEnabled: boolean }
4. API key encryption uses existing encryptSecret utility
5. getCreatorClaudeApiKey helper function is exported
6. TypeScript compiles without errors in x402-jobs-api
</verification>

<success_criteria>

- Database migration ready for user to apply
- Claude integration endpoints match what ClaudeCard frontend expects
- API keys are encrypted at rest
- Helper function ready for execution engine to use
- Build passes: `cd x402-jobs-api && npm run build`
  </success_criteria>

<output>
After completion, create `.planning/phases/03-server-execution/03-01-SUMMARY.md`
</output>
