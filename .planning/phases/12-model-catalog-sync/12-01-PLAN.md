---
phase: 12-model-catalog-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/x402-jobs/migrations/006_add_ai_models_curation.sql
  - apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
  - apps/x402-jobs-api/src/inngest/index.ts
  - apps/x402-jobs-api/src/routes/inngest.ts
  - apps/x402-jobs-api/src/routes/admin.ts
autonomous: true

must_haves:
  truths:
    - "OpenRouter models sync daily at 3am UTC (verify: Inngest cron registered with '0 3 * * *')"
    - "Model records include modality type (verify: ai_models.modality column exists)"
    - "Popular models flagged for curated view (verify: ai_models.is_curated column exists)"
    - "Admin can manually trigger sync (verify: POST /admin/sync-models returns success)"
    - "Sync function upserts models preserving is_curated flag (verify: upsert ignores is_curated)"
  artifacts:
    - path: "apps/x402-jobs/migrations/006_add_ai_models_curation.sql"
      provides: "Schema extension for modality and curation"
      contains: "is_curated"
    - path: "apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts"
      provides: "Inngest cron function for daily sync"
      contains: "sync-openrouter-models"
    - path: "apps/x402-jobs-api/src/routes/admin.ts"
      provides: "Manual trigger endpoint"
      contains: "sync-models"
  key_links:
    - from: "apps/x402-jobs-api/src/routes/inngest.ts"
      to: "sync-openrouter-models function"
      via: "serve() functions array"
      pattern: "syncOpenRouterModels"
    - from: "apps/x402-jobs-api/src/inngest/index.ts"
      to: "sync-openrouter-models.ts"
      via: "export statement"
      pattern: "export.*syncOpenRouterModels"
---

<objective>
Create daily Inngest cron job to sync OpenRouter models to ai_models table.

Purpose: Populate and maintain the model catalog that users will browse when creating OpenRouter resources. Models need modality flags (text/image/video/audio) and curation flags for the default curated view.

Output: Inngest function running daily at 3am UTC, syncing 200+ models with modality categorization and preserving manual curation flags. Admin endpoint for manual testing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-model-catalog-sync/12-CONTEXT.md
@.planning/phases/11-database-foundation/11-01-SUMMARY.md

# Existing patterns to follow

@apps/x402-jobs-api/src/inngest/functions/poll-bazaar-discovery.ts
@packages/services/scripts/update-openrouter-models.ts

# Schema reference

@supabase/migrations/20250120_create_ai_models_table.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for ai_models curation columns</name>
  <files>apps/x402-jobs/migrations/006_add_ai_models_curation.sql</files>
  <action>
Create migration file `006_add_ai_models_curation.sql` with two column additions:

**1. modality column**

```sql
ALTER TABLE ai_models
ADD COLUMN IF NOT EXISTS modality TEXT NOT NULL DEFAULT 'text';
```

Valid values: 'text', 'image', 'video', 'audio', 'embedding', 'multimodal'
Add CHECK constraint: `CHECK (modality IN ('text', 'image', 'video', 'audio', 'embedding', 'multimodal'))`

**2. is_curated column**

```sql
ALTER TABLE ai_models
ADD COLUMN IF NOT EXISTS is_curated BOOLEAN NOT NULL DEFAULT false;
```

**3. Indexes**

- Index on modality for filtering: `CREATE INDEX IF NOT EXISTS idx_ai_models_modality ON ai_models(modality);`
- Index on is_curated for curated view: `CREATE INDEX IF NOT EXISTS idx_ai_models_curated ON ai_models(is_curated) WHERE is_curated = true;`

**4. Comments**

- Document modality column: stores output modality of model
- Document is_curated: manually flagged for curated view (not synced from OpenRouter)

**5. Initial curation seed (commented out)**
Include a commented UPDATE statement that marks popular models as curated:

- Claude models (anthropic/claude-\*)
- GPT-4o, GPT-4-turbo (openai/gpt-4o*, openai/gpt-4-turbo*)
- Gemini 2.0, Gemini Pro (google/gemini-2*, google/gemini-pro*)
- Llama 3.3 (meta-llama/llama-3.3\*)
- Mistral Large (mistralai/mistral-large\*)
- Grok (x-ai/grok\*)

This seed is optional - admin can curate via direct database access.

**6. Rollback section**
Include commented rollback statements.
</action>
<verify>

```bash
# Verify file exists
test -f apps/x402-jobs/migrations/006_add_ai_models_curation.sql

# Verify columns
grep -q "ADD COLUMN.*modality" apps/x402-jobs/migrations/006_add_ai_models_curation.sql
grep -q "ADD COLUMN.*is_curated" apps/x402-jobs/migrations/006_add_ai_models_curation.sql

# Verify CHECK constraint
grep -q "CHECK.*modality IN" apps/x402-jobs/migrations/006_add_ai_models_curation.sql

# Verify indexes
grep -q "idx_ai_models_modality" apps/x402-jobs/migrations/006_add_ai_models_curation.sql
grep -q "idx_ai_models_curated" apps/x402-jobs/migrations/006_add_ai_models_curation.sql
```

  </verify>
  <done>
Migration file exists with modality column (CHECK constrained), is_curated column, both indexes, and optional curation seed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Inngest sync function with cron and manual trigger</name>
  <files>apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts, apps/x402-jobs-api/src/inngest/index.ts, apps/x402-jobs-api/src/routes/inngest.ts</files>
  <action>
**2a. Create sync-openrouter-models.ts**

Port and adapt logic from `packages/services/scripts/update-openrouter-models.ts`:

```typescript
// File: apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts

import { inngest } from "../../lib/inngest";
import { getSupabase } from "../../lib/supabase";

// Types from OpenRouter API (copy from existing script)
interface OpenRouterAPIModel { ... }
interface OpenRouterAPIResponse { ... }

// Helper functions (copy from existing script)
function formatProviderName(provider: string): string { ... }
function formatModelName(modelId: string, apiName?: string): string { ... }
function detectVisionSupport(model: OpenRouterAPIModel): boolean { ... }
function detectWebSearchSupport(model: OpenRouterAPIModel): boolean { ... }
function detectToolCallingSupport(model: OpenRouterAPIModel): boolean { ... }

// NEW: Detect modality from OpenRouter architecture data
function detectModality(model: OpenRouterAPIModel): string {
  const outputModalities = model.architecture?.output_modalities || [];
  const inputModalities = model.architecture?.input_modalities || [];

  // Check output modality first
  if (outputModalities.includes('image')) return 'image';
  if (outputModalities.includes('video')) return 'video';
  if (outputModalities.includes('audio')) return 'audio';

  // Check if embedding model
  const modality = model.architecture?.modality?.toLowerCase() || '';
  if (modality.includes('embedding') || model.id.includes('embedding')) return 'embedding';

  // Check if multimodal input
  if (inputModalities.includes('image') || inputModalities.includes('audio')) return 'multimodal';

  // Default to text
  return 'text';
}
```

**Cron function (daily at 3am UTC):**

```typescript
export const syncOpenRouterModels = inngest.createFunction(
  {
    id: "sync-openrouter-models",
    retries: 2,
  },
  { cron: "0 3 * * *" }, // 3am UTC daily
  async ({ step, logger }) => {
    // Step 1: Fetch models from OpenRouter
    const models = await step.run("fetch-openrouter-models", async () => {
      logger.info("Fetching models from OpenRouter API...");
      const response = await fetch("https://openrouter.ai/api/v1/models", {
        headers: { "Content-Type": "application/json" },
      });
      if (!response.ok)
        throw new Error(`OpenRouter API error: ${response.status}`);
      const data: OpenRouterAPIResponse = await response.json();
      if (!data.data) throw new Error("Invalid response format");
      logger.info(`Fetched ${data.data.length} models`);
      return data.data;
    });

    // Step 2: Transform and upsert
    const result = await step.run("upsert-models", async () => {
      const supabase = getSupabase();

      // Transform models with explicit field mapping (satisfies MODL-02)
      const modelsToUpsert = models
        .filter(/* filter logic from script */)
        .map((model) => ({
          // MODL-02 Required Field Mappings:
          openrouter_id: model.id,                                    // id - unique identifier
          name: formatModelName(model.id, model.name),                // name - display name
          provider: formatProviderName(model.id),                     // provider - extracted from model.id
          modality: detectModality(model),                            // modality - text/image/video/audio/embedding/multimodal
          input_cost_per_million: model.pricing?.prompt               // input pricing
            ? parseFloat(model.pricing.prompt) * 1000000
            : null,
          output_cost_per_million: model.pricing?.completion          // output pricing
            ? parseFloat(model.pricing.completion) * 1000000
            : null,
          context_length: model.context_length || null,               // context length
          capabilities: {                                             // capabilities object
            vision: detectVisionSupport(model),
            web_search: detectWebSearchSupport(model),
            tool_calling: detectToolCallingSupport(model),
          },
          // NOTE: Do NOT include is_curated - preserve manual curation
        }));

      // Upsert with onConflict
      const { error } = await supabase
        .from("ai_models")
        .upsert(modelsToUpsert, {
          onConflict: "openrouter_id",
          ignoreDuplicates: false,
        });

      if (error) throw error;

      return {
        total: modelsToUpsert.length,
        text: modelsToUpsert.filter((m) => m.modality === "text").length,
        image: modelsToUpsert.filter((m) => m.modality === "image").length,
        video: modelsToUpsert.filter((m) => m.modality === "video").length,
        audio: modelsToUpsert.filter((m) => m.modality === "audio").length,
        multimodal: modelsToUpsert.filter((m) => m.modality === "multimodal")
          .length,
      };
    });

    logger.info("Sync complete", result);
    return result;
  },
);
```

**Manual trigger function:**

```typescript
export const triggerModelSync = inngest.createFunction(
  {
    id: "trigger-model-sync",
    retries: 1,
  },
  { event: "x402/models.sync" },
  async ({ step, logger }) => {
    logger.info("Manual model sync triggered");
    // Same logic as cron function...
    // (Can extract shared function to avoid duplication)
  },
);
```

**2b. Update inngest/index.ts**

Add exports:

```typescript
export {
  syncOpenRouterModels,
  triggerModelSync,
} from "./functions/sync-openrouter-models";
```

**2c. Update routes/inngest.ts**

Import and add to functions array:

```typescript
import {
  // ... existing imports
  syncOpenRouterModels,
  triggerModelSync,
} from "../inngest";

export const inngestHandler = serve({
  client: inngest,
  functions: [
    // ... existing functions
    // OpenRouter model sync
    syncOpenRouterModels,
    triggerModelSync,
  ],
});
```

  </action>
  <verify>
```bash
# Verify function file exists with cron
grep -q "sync-openrouter-models" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "0 3 \* \* \*" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts

# Verify modality detection
grep -q "detectModality" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts

# Verify MODL-02 field mappings are present
grep -q "openrouter_id:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "name:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "provider:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "modality:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "input_cost_per_million:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "output_cost_per_million:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "context_length:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts
grep -q "capabilities:" apps/x402-jobs-api/src/inngest/functions/sync-openrouter-models.ts

# Verify exports
grep -q "syncOpenRouterModels" apps/x402-jobs-api/src/inngest/index.ts

# Verify registration
grep -q "syncOpenRouterModels" apps/x402-jobs-api/src/routes/inngest.ts
```
  </verify>
  <done>
Inngest sync function runs daily at 3am UTC, upserts models with all MODL-02 required fields (id, name, provider, modality, input/output pricing, context length, capabilities), preserves is_curated flag, and manual trigger event registered.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add admin endpoint for manual sync trigger</name>
  <files>apps/x402-jobs-api/src/routes/admin.ts</files>
  <action>
Add endpoint to admin.ts following existing pattern:

```typescript
// POST /admin/sync-models - Manually trigger OpenRouter model sync
router.post("/sync-models", adminAuth, async (req: Request, res: Response) => {
  try {
    // Import inngest client
    const { inngest } = await import("../lib/inngest");

    // Send event to trigger sync
    await inngest.send({
      name: "x402/models.sync",
      data: {
        triggeredBy: "admin",
        triggeredAt: new Date().toISOString(),
      },
    });

    console.log("[Admin] Model sync triggered");

    res.json({
      success: true,
      message: "Model sync triggered. Check Inngest dashboard for progress.",
    });
  } catch (error) {
    console.error("[Admin] Error triggering model sync:", error);
    res.status(500).json({ error: "Failed to trigger model sync" });
  }
});
```

Protected by existing adminAuth middleware (requires ADMIN_TOKEN).
</action>
<verify>

```bash
# Verify endpoint added
grep -q "sync-models" apps/x402-jobs-api/src/routes/admin.ts
grep -q "x402/models.sync" apps/x402-jobs-api/src/routes/admin.ts
```

  </verify>
  <done>
Admin can POST to /admin/sync-models with ADMIN_TOKEN to manually trigger OpenRouter model sync.
  </done>
</task>

</tasks>

<verification>
1. Migration file has modality and is_curated columns with indexes
2. Inngest function registered with daily cron (0 3 * * *)
3. Function exports added to inngest/index.ts
4. Function registered in routes/inngest.ts serve() array
5. Admin endpoint responds to POST /admin/sync-models
6. Modality detection handles text, image, video, audio, embedding, multimodal
7. Upsert preserves is_curated flag (not included in upsert payload)
8. All MODL-02 fields explicitly mapped: id, name, provider, modality, input/output pricing, context length, capabilities
</verification>

<success_criteria>

- [ ] `006_add_ai_models_curation.sql` exists with modality and is_curated columns
- [ ] CHECK constraint on modality column limits valid values
- [ ] Indexes created for modality and is_curated filtering
- [ ] `sync-openrouter-models.ts` has cron function at 3am UTC
- [ ] `sync-openrouter-models.ts` has manual trigger function
- [ ] detectModality() categorizes models as text/image/video/audio/embedding/multimodal
- [ ] MODL-02 fields explicitly mapped: openrouter_id, name, provider, modality, input_cost_per_million, output_cost_per_million, context_length, capabilities
- [ ] Functions exported from inngest/index.ts
- [ ] Functions registered in routes/inngest.ts
- [ ] POST /admin/sync-models endpoint triggers x402/models.sync event
- [ ] STATE.md updated with manual migration step
      </success_criteria>

<output>
After completion, create `.planning/phases/12-model-catalog-sync/12-01-SUMMARY.md`
</output>
