---
phase: 04-caller-detail-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx
  - src/components/pages/PromptTemplateDetailPage/index.ts
  - src/app/resources/[serverSlug]/[resourceSlug]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Caller can view prompt template detail page with name, description, parameters, price, and usage count"
    - "Caller never sees the system prompt content"
    - "Caller can fill parameter values via auto-generated form"
    - "Required parameters are enforced with validation, defaults are pre-filled"
    - "Caller can provide optional user message when allows_user_message is true"
    - "Response displays in UI when execution completes"
    - "Caller can copy output to clipboard"
  artifacts:
    - path: "src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx"
      provides: "Prompt template detail page component with form and execution"
      min_lines: 200
    - path: "src/components/pages/PromptTemplateDetailPage/index.ts"
      provides: "Component export"
      exports: ["PromptTemplateDetailPage"]
    - path: "src/app/resources/[serverSlug]/[resourceSlug]/page.tsx"
      provides: "Route that detects resource type and renders appropriate component"
      contains: "prompt_template"
  key_links:
    - from: "src/app/resources/[serverSlug]/[resourceSlug]/page.tsx"
      to: "src/components/pages/PromptTemplateDetailPage"
      via: "dynamic import based on resource_type"
      pattern: "PromptTemplateDetailPage"
    - from: "src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx"
      to: "/instant/@{serverSlug}/{resourceSlug}"
      via: "authenticatedFetch POST"
      pattern: "authenticatedFetch.*instant"
---

<objective>
Create the caller-facing detail page for prompt_template resources where callers can view template info, fill parameters, execute the template, and copy results.

Purpose: Enable callers to use prompt templates without seeing the protected system prompt. This is the primary caller experience for monetized AI prompts.

Output: PromptTemplateDetailPage component with parameter form, execution handling, and result display following existing ResourceDetailPage patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-caller-detail-page/04-RESEARCH.md
@.planning/phases/04-caller-detail-page/04-CONTEXT.md

# Key source files for patterns

@src/components/pages/ResourceDetailPage/ResourceDetailPage.tsx
@src/types/prompt-template.ts
@src/lib/api.ts
@src/app/resources/[serverSlug]/[resourceSlug]/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PromptTemplateDetailPage component</name>
  <files>
    src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx
    src/components/pages/PromptTemplateDetailPage/index.ts
  </files>
  <action>
Create the PromptTemplateDetailPage component following ResourceDetailPage patterns:

**Component Structure:**

```typescript
interface Props {
  serverSlug: string;
  resourceSlug: string;
}
```

**Data Fetching:**

- Use `useSWR` with `publicFetcher` to fetch `/api/v1/resources/${serverSlug}/${resourceSlug}`
- Type the response as `{ resource: PromptTemplatePublicView }` from `@/types/prompt-template`
- Handle loading and error states like ResourceDetailPage

**Header Section (follow ResourceDetailPage layout):**

- Avatar with Sparkles icon fallback (purple theme for prompt_template)
- Name display: `@{username}/{resourceSlug}` format with link to user profile
- Description below name
- Stats line: `{usage_count} runs - ${price_usdc} per run - {network}`
- Use `formatPrice` from `@/lib/format` for price display
- Use ChainIcon for network display

**Parameter Form Section:**

- Sort parameters: required first, then optional
- For each parameter from `resource.parameters`:
  - Label with parameter name (humanized: replace \_ with space, add space before caps)
  - Required indicator (red asterisk) if `param.required`
  - Input field with `param.description` as placeholder
  - Pre-fill value from `param.default` if present
- Store form values in `formData: Record<string, string>` state
- Store field errors in `fieldErrors: Record<string, string>` state

**User Message Input (conditional):**

- Show Textarea for user message ONLY when `resource.allows_user_message === true`
- Place after parameters, before Run button
- Label: "Your Message (optional)"
- Store in separate `userMessage: string` state

**Run Button:**

- Disabled states: `!user` (show "Login to Run"), `isSubmitting`, or form validation fails
- Show price on button: "Run (${price_usdc})"
- For owner testing: Check if current user owns the resource (match authenticated user with resource owner) and show "Run (Free)" instead

**Validation (validateForm function):**

- Check all required parameters have non-empty values
- Set field errors for missing required fields
- Return true only if all required fields filled

**Create index.ts:**

```typescript
export { default as PromptTemplateDetailPage } from "./PromptTemplateDetailPage";
export default PromptTemplateDetailPage;
```

**Imports needed:**

- useState, useMemo, useEffect from react
- Link from next/link
- useSWR from swr
- publicFetcher, authenticatedFetch from @/lib/api
- Button, Input, Textarea, Label from @repo/ui
- Loader2, Copy, Check, CheckCircle, AlertCircle, Sparkles from lucide-react
- useAuth from @/contexts/AuthContext
- BaseLayout from @/components/BaseLayout
- Avatar from @/components/Avatar
- ChainIcon from @/components/icons/ChainIcons
- formatPrice from @/lib/format
- getNetwork from @/lib/networks
- PromptTemplatePublicView from @/types/prompt-template
  </action>
  <verify>
  File exists at `src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx` with:
- useSWR fetching resource data
- Header section with avatar, name, stats
- Parameter form rendering from resource.parameters
- Conditional user message textarea
- Form validation logic
- Run button with proper disabled states
  </verify>
  <done>
  Component renders prompt template details with parameter form, user message input (when enabled), and Run button.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add execution and response display</name>
  <files>
    src/components/pages/PromptTemplateDetailPage/PromptTemplateDetailPage.tsx
  </files>
  <action>
Add execution handling and response display to PromptTemplateDetailPage:

**State for execution:**

```typescript
const [isSubmitting, setIsSubmitting] = useState(false);
const [error, setError] = useState<string | null>(null);
const [result, setResult] = useState<string | null>(null);
const [outputCopied, setOutputCopied] = useState(false);
```

**handleSubmit function:**

```typescript
const handleSubmit = async () => {
  if (!resource) return;
  if (!user) {
    // TODO: Could open login modal, for now just return
    return;
  }
  if (!validateForm()) return;

  setIsSubmitting(true);
  setError(null);
  setResult(null);

  try {
    // Build request body with parameters and optional user_message
    const body: Record<string, string> = { ...formData };
    if (resource.allows_user_message && userMessage.trim()) {
      body.user_message = userMessage.trim();
    }

    // Determine if owner testing (resource owner matches logged-in user)
    const isOwner = user.id === resource.owner_id; // Note: may need to check server_verified_owner_id pattern

    const response = await authenticatedFetch(
      `/instant/@${serverSlug}/${resourceSlug}`,
      {
        method: "POST",
        body: JSON.stringify(body),
        headers: isOwner ? { "X-OWNER-TEST": "true" } : undefined,
      },
    );

    // Handle non-streaming response (per CONTEXT.md - no streaming display)
    const data = await response.json();

    if (!response.ok) {
      if (response.status === 402 && data.required !== undefined) {
        setError(
          `Insufficient balance: need $${data.required.toFixed(2)} USDC`,
        );
      } else {
        setError(data.error || data.message || "Execution failed");
      }
      return;
    }

    // Response contains the Claude output
    // Backend returns { response: string, usage?: {...} } for prompt_template
    setResult(data.response || JSON.stringify(data, null, 2));
  } catch (err) {
    setError(err instanceof Error ? err.message : "Request failed");
  } finally {
    setIsSubmitting(false);
  }
};
```

**Note on owner detection:**
The PromptTemplatePublicView type may not include owner_id. Check if the resource fetch returns ownership info, or compare serverSlug (which is @username format) with the authenticated user's username.

Better approach:

```typescript
// serverSlug is @username format for hosted resources
const ownerUsername = serverSlug.startsWith("@") ? serverSlug.slice(1) : null;
const isOwner = user && ownerUsername && user.username === ownerUsername;
```

**Loading State during execution (below Run button):**

```tsx
{
  isSubmitting && (
    <div className="mt-6 bg-muted rounded-lg p-6 flex items-center justify-center gap-2 text-muted-foreground">
      <Loader2 className="h-4 w-4 animate-spin" />
      Running...
    </div>
  );
}
```

**Error Display (below loading, when error present):**

```tsx
{
  error && !isSubmitting && (
    <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 mt-6">
      <div className="flex items-start gap-2">
        <AlertCircle className="h-4 w-4 text-destructive mt-0.5 flex-shrink-0" />
        <p className="text-sm text-destructive">{error}</p>
      </div>
    </div>
  );
}
```

**Result Display with Copy (below error area, when result present):**

```tsx
{
  result && !isSubmitting && (
    <div className="mt-6">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm font-semibold flex items-center gap-2">
          <CheckCircle className="h-4 w-4 text-emerald-500" />
          Output
        </h3>
        <button
          onClick={() => copyToClipboard(result)}
          className="text-xs text-muted-foreground hover:text-foreground flex items-center gap-1 transition-colors"
        >
          {outputCopied ? (
            <>
              <Check className="h-3 w-3" />
              Copied
            </>
          ) : (
            <>
              <Copy className="h-3 w-3" />
              Copy
            </>
          )}
        </button>
      </div>
      <div className="bg-muted rounded-lg p-4 whitespace-pre-wrap text-sm font-mono">
        {result}
      </div>
    </div>
  );
}
```

**copyToClipboard helper:**

```typescript
const copyToClipboard = (text: string) => {
  navigator.clipboard.writeText(text);
  setOutputCopied(true);
  setTimeout(() => setOutputCopied(false), 2000);
};
```

**Wire handleSubmit to Run button onClick.**
</action>
<verify>
Component includes:

- handleSubmit function with authenticatedFetch to /instant endpoint
- X-OWNER-TEST header for owner testing
- Loading state with spinner
- Error display with AlertCircle
- Result display with copy button
- copyToClipboard function with 2-second feedback
  </verify>
  <done>
  Caller can execute template, see loading state, handle errors, view result, and copy output to clipboard.
  </done>
  </task>

<task type="auto">
  <name>Task 3: Wire routing for prompt_template detection</name>
  <files>
    src/app/resources/[serverSlug]/[resourceSlug]/page.tsx
  </files>
  <action>
Update the resource detail route to detect resource type and render appropriate component.

**Current state:** Route unconditionally renders ResourceDetailPage.

**New approach:**
The cleanest approach is to have the route component handle detection. Since we need to know the resource type before choosing a component, we have two options:

**Option A - Client-side detection in a wrapper:**
Create a ResourceRouter component that fetches resource, checks type, renders appropriate page.

**Option B - Server-side detection (preferred for SEO):**
Fetch resource type server-side, then render correct client component.

**Implementation (Option B - simpler):**

```typescript
import ResourceDetailPage from "@/components/pages/ResourceDetailPage";
import PromptTemplateDetailPage from "@/components/pages/PromptTemplateDetailPage";

const API_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:3011";

interface PageProps {
  params: Promise<{ serverSlug: string; resourceSlug: string }>;
}

// Helper to fetch resource type
async function getResourceType(serverSlug: string, resourceSlug: string): Promise<string | null> {
  try {
    const res = await fetch(
      `${API_URL}/api/v1/resources/${serverSlug}/${resourceSlug}`,
      { next: { revalidate: 60 } } // Cache for 60 seconds
    );
    if (!res.ok) return null;
    const data = await res.json();
    return data.resource?.resource_type || null;
  } catch {
    return null;
  }
}

export default async function Page({ params }: PageProps) {
  const { serverSlug, resourceSlug } = await params;

  const resourceType = await getResourceType(serverSlug, resourceSlug);

  if (resourceType === 'prompt_template') {
    return <PromptTemplateDetailPage serverSlug={serverSlug} resourceSlug={resourceSlug} />;
  }

  // Default to ResourceDetailPage for external, proxy, etc.
  return <ResourceDetailPage serverSlug={serverSlug} resourceSlug={resourceSlug} />;
}
```

**Why this works:**

- Server fetches resource type (fast, cached)
- Renders correct client component based on type
- Both components then do their own SWR fetching for full data
- Fallback to ResourceDetailPage for unknown types

**Note:** If the fetch fails or type is unknown, we default to ResourceDetailPage which will handle its own 404/error state.
</action>
<verify>
Run `npm run build` or `npm run dev` and:

1. Navigate to a prompt_template resource: Should render PromptTemplateDetailPage
2. Navigate to a regular resource: Should render ResourceDetailPage
3. Navigate to non-existent resource: Should show 404 (handled by ResourceDetailPage)
   </verify>
   <done>
   Route correctly detects prompt_template resources and renders PromptTemplateDetailPage, while other resource types continue to use ResourceDetailPage.
   </done>
   </task>

</tasks>

<verification>
After all tasks complete:

1. **Type Check:** `npx tsc --noEmit` passes without errors
2. **Build Check:** `npm run build` completes successfully
3. **Manual Testing:**
   - Create a prompt_template resource via creator UI (Phase 2)
   - Navigate to its detail page
   - Verify: name, description, parameters, price, usage count displayed
   - Verify: system prompt NOT visible anywhere
   - Fill in parameters (required and optional)
   - If allows_user_message: verify user message textarea appears
   - Click Run (must be logged in)
   - Verify: loading state shows "Running..."
   - Verify: result displays in output area
   - Click Copy, verify clipboard contains result
     </verification>

<success_criteria>

- PromptTemplateDetailPage component exists and renders prompt template details
- Parameter form auto-generates from template parameters with validation
- Required parameters show asterisk, are validated before submit
- Default values pre-fill optional parameters
- User message input appears only when allows_user_message is true
- Run button calls /instant endpoint with parameters
- Loading state shows during execution
- Error state shows API errors with friendly messages
- Result displays in styled output area when execution completes
- Copy button copies result to clipboard with visual feedback
- Route correctly routes prompt_template resources to new component
- System prompt content never exposed to caller
  </success_criteria>

<output>
After completion, create `.planning/phases/04-caller-detail-page/04-01-SUMMARY.md` using the summary template.
</output>
