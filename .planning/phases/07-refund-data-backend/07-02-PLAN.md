---
phase: 07-refund-data-backend
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/api/admin/backfill-refunds/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Admin can trigger backfill of supports_refunds for existing resources"
    - "Backfill re-verifies each resource URL and extracts supportsRefunds"
    - "Backfill handles rate limiting and failures gracefully"
  artifacts:
    - path: "src/app/api/admin/backfill-refunds/route.ts"
      provides: "Admin endpoint for backfilling supports_refunds"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/admin/backfill-refunds/route.ts"
      to: "/api/v1/resources/verify"
      via: "fetch to external verify endpoint"
      pattern: "resources/verify"
---

<objective>
Create admin endpoint to backfill supports_refunds for existing resources.

Purpose: Allow existing resources to display refund badges by re-verifying their x402 endpoints and extracting supportsRefunds.
Output: Admin-only API endpoint that iterates through resources and updates their supports_refunds field.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-refund-data-backend/07-RESEARCH.md
@.planning/phases/07-refund-data-backend/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin backfill endpoint</name>
  <files>src/app/api/admin/backfill-refunds/route.ts</files>
  <action>
Create a Next.js API route that:

1. **Authentication**: Verify the request is from an admin user (check Supabase auth + admin role or use a simple API key from env)

2. **Fetch resources to backfill**:
   - Query resources where supports_refunds IS NULL or needs refresh
   - Accept optional query params: `limit` (default 10), `offset` (default 0)

3. **For each resource**:
   - Fetch the 402 response from `resource_url` (same as verify endpoint does)
   - Extract `supportsRefunds` from `accepts[].extra`
   - Update the resource via the external API (PATCH /resources/:id) or direct Supabase update

4. **Rate limiting**:
   - Add delay between requests (e.g., 500ms) to avoid overwhelming x402 endpoints
   - Use try/catch to handle individual failures without stopping the batch

5. **Response**:
   - Return JSON with: processed count, updated count, failed count, errors array

Pattern for extracting supportsRefunds:

```typescript
const supportsRefunds =
  response.accepts?.some(
    (accept: { extra?: Record<string, unknown> }) =>
      accept.extra?.supportsRefunds === true,
  ) ?? false;
```

Use existing patterns from the codebase:

- Look at other admin endpoints in src/app/api/admin/ for auth pattern
- Use createServerClient from @supabase/ssr for server-side Supabase access
- Use API_URL from @/lib/api for external API calls

Note: This is a utility endpoint, not a production-critical feature. Simple implementation is fine.
</action>
<verify>
File exists: `ls src/app/api/admin/backfill-refunds/route.ts`
Build passes: `npm run build`
Route exports POST handler: `grep -n "export.*POST" src/app/api/admin/backfill-refunds/route.ts`
</verify>
<done>Admin backfill endpoint exists, builds successfully, and exports POST handler</done>
</task>

<task type="auto">
  <name>Task 2: Document backfill usage</name>
  <files>migrations/004_add_supports_refunds.sql</files>
  <action>
Add a comment block at the end of the migration file documenting how to backfill existing resources:

```sql
-- ============================================================================
-- BACKFILL EXISTING RESOURCES
-- ============================================================================
-- After applying this migration, backfill existing resources by calling:
--
--   POST /api/admin/backfill-refunds?limit=50
--
-- The endpoint will:
-- 1. Fetch resources where supports_refunds has not been set
-- 2. Re-verify each resource URL to extract supportsRefunds from x402 response
-- 3. Update the supports_refunds column
--
-- Run multiple times with offset parameter if you have many resources:
--   POST /api/admin/backfill-refunds?limit=50&offset=0
--   POST /api/admin/backfill-refunds?limit=50&offset=50
--   etc.
```

This keeps the backfill instructions with the migration for future reference.
</action>
<verify>
Grep for backfill comment: `grep -n "BACKFILL" migrations/004_add_supports_refunds.sql`
</verify>
<done>Backfill documentation added to migration file</done>
</task>

</tasks>

<verification>
1. Admin endpoint exists at src/app/api/admin/backfill-refunds/route.ts
2. Build passes without errors
3. Migration file includes backfill documentation
</verification>

<success_criteria>

- Backfill endpoint created with proper auth check
- Endpoint handles batch processing with rate limiting
- Migration file documents the backfill process
- Build succeeds
  </success_criteria>

<output>
After completion, create `.planning/phases/07-refund-data-backend/07-02-SUMMARY.md`
</output>
